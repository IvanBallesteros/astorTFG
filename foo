
We have worked on two fronts: using sequence-to-sequence learning to automatically repair programs and metaprogramming for fixing static analysis warnings.

\textbf{Repair with sequence-to-sequence learning} Sequence-to-sequence (seq2seq) learning is a branch of machine learning, mostly used for machine translation: the algorithm seq2seq learns to translate text from one language (say French) to another language (say Swedish) by generalizing over large amounts of sentence pairs from French to Swedish. In the context of program repair, we learn to 'translate' from one sequence of program tokens (a buggy program) to a different sequence of program tokens (a fixed program). The training data is readily available: we have millions of commits in open-source code repositories. Yet, we still have major challenges to overcome when it comes to using sequence-to-sequence learning on code:
\begin{enumerate*}
    \item the raw data is rather noisy; one must deploy significant effort to identify and curate commits that focus on a clear task, in particular a bugg fixing task;
    \item contrary to natural language, usage of rare words (identifiers, numbers, etc) is often fatal in machine learning on code; in natural language some errors may be tolerable thanks to the intelligence of the human reader while in programming languages the compiler (or interpreter) is strict
    \item in natural language, the dependencies are often in the same sentence (``it'' refers to ``dog'' just before) , or within a couple of sentences, while in programming, the dependencies have a longer range: one may use a variable that has been declared dozens of lines before.
\end{enumerate*}

In Trustfull, we have realized an end-to-end program repair approach which works as follows.
First, we focus on one-line fixes: we predict the fixed version of a buggy line. For this, we create a carefully curated training and testing dataset of one-line commits.
Second, we devise a sequence-to-sequence network architecture that is specifically designed to address the two main aforementioned challenges.
To address the unlimited vocabulary problem, we use the copy mechanism; this allows us to predict the fixed line, even if the fix contains a token that was too rare to be considered in the vocabulary (i.e. an API call that appears only in few cases, or a rare identifier used only in one class). This copy mechanism works even if the fixed line should contain tokens which were not in the training set.
To address the dependency problem, we have devised an \textit{abstract buggy context} from the buggy class, which captures the most important context around the buggy source code and reduces the complexity of the input sequence. This enables us to capture long range dependencies that are required for the fix.

To sum up, our contribution is an approach for fixing bugs based on sequence-to-sequence learning on token sequences. This approach uses the copy mechanism to overcome the unlimited vocabulary problem in source code. We have evaluated our approach on 4,711 real bug fixing tasks. Our golden trained model is able to perfectly fix 950/4,711 testing samples. We have provided unique qualitative insights of interesting repair operators captured by sequence-to-sequence learning on the considered training dataset.
We are now extending this work to repair security vulnearbilities in C code.

\textbf{Repair with metaprogramming} 
Static analysis can uncover a multitude
of bugs in a reasonable time frame but
is plagued by issues such as high false-positive alert rates and unclear
calls to action, making it underutilized considering the benefits it can bring
with its bug-finding abilities. We have worked to reduce the shortcomings of
static analysis by implementing and evaluating a metaprogramming approach for
automatically repairing bugs found by static analysis. The approach is implemented for Java to repair the warnings identified by SonarQube, the leading static analyzer for Java.
Our results show that
the approach and developed tool are valuable to decrease the number of problems which static analysis finds. Two possible ways of integrating the
created tool into existing developer workflows are prototyped and a compar-
ison with a similar tool is performed to showcase the different approachesâ€™
differences, strengths and weaknesses.
